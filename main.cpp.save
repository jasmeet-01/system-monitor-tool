#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <dirent.h>
#include <unistd.h>
#include <algorithm>
#include <thread>
#include <chrono>
#include <termios.h>
#include <fcntl.h>

struct CpuTimes {
    long long user, nice, system, idle, iowait, irq, softirq, steal;
};

struct ProcessInfo {
    int pid;
    std::string name;
    long mem_usage_kb;
    double cpu_usage;
};

CpuTimes read_cpu_times() {
    std::ifstream file("/proc/stat");
    std::string line;
    std::getline(file, line);
    std::istringstream iss(line);
    std::string cpu_label;
    CpuTimes times{};
    iss >> cpu_label >> times.user >> times.nice >> times.system >> times.idle >> times.iowait
        >> times.irq >> times.softirq >> times.steal;
    return times;
}

double calculate_cpu_usage(const CpuTimes& prev, const CpuTimes& curr) {
    long long prev_idle = prev.idle + prev.iowait;
    long long curr_idle = curr.idle + curr.iowait;

    long long prev_non_idle = prev.user + prev.nice + prev.system + prev.irq + prev.softirq + prev.steal;
    long long curr_non_idle = curr.user + curr.nice + curr.system + curr.irq + curr.softirq + curr.steal;

    long long prev_total = prev_idle + prev_non_idle;
    long long curr_total = curr_idle + curr_non_idle;

    long long totald = curr_total - prev_total;
    long long idled = curr_idle - prev_idle;

    if (totald == 0) return 0.0;
    return (totald - idled) * 100.0 / totald;
}

std::pair<long long, long long> read_memory() {
    std::ifstream file("/proc/meminfo");
    std::string line;
    long long mem_total = 0, mem_available = 0;
    while (std::getline(file, line)) {
        std::istringstream iss(line);
        std::string key;
        long long value;
        std::string unit;
        iss >> key >> value >> unit;
        if (key == "MemTotal:") mem_total = value;
        if (key == "MemAvailable:") mem_available = value;
    }
    return {mem_total, mem_available};
}

std::vector<int> get_pids() {
    std::vector<int> pids;
    DIR* proc = opendir("/proc");
    if (!proc) return pids;
    struct dirent* entry;
    while ((entry = readdir(proc)) != nullptr) {
        if (entry->d_type == DT_DIR) {
            std::string dir_name = entry->d_name;
            if (std::all_of(dir_name.begin(), dir_name.end(), ::isdigit)) {
                pids.push_back(std::stoi(dir_name));
            }
        }
    }
    closedir(proc);
    return pids;
}

ProcessInfo get_process_info(int pid) {
    ProcessInfo info;
    info.pid = pid;
    info.cpu_usage = 0.0;  // Placeholder

    std::ifstream comm("/proc/" + std::to_string(pid) + "/comm");
    if (comm.is_open())
        std::getline(comm, info.name);
    comm.close();

    std::ifstream statm("/proc/" + std::to_string(pid) + "/statm");
    long size = 0, resident = 0;
    if (statm.is_open())
        statm >> size >> resident;
    statm.close();

    long page_size_kb = sysconf(_SC_PAGESIZE) / 1024;
    info.mem_usage_kb = resident * page_size_kb;

    return info;
}

// Check if a key has been pressed (non-blocking)
int kbhit() {
    static const int STDIN = 0;
    static bool initialized = false;
    static struct termios oldt, newt;

    if (!initialized) {
        tcgetattr(STDIN, &oldt); // Save old settings
        newt = oldt;
        newt.c_lflag &= ~(ICANON | ECHO); // Disable buffering and echo
        tcsetattr(STDIN, TCSANOW, &newt);
        setbuf(stdin, NULL);
        initialized = true;
    }

    int bytesWaiting;
    ioctl(STDIN, FIONREAD, &bytesWaiting);
    return bytesWaiting;
}

void display_process_list() {
    std::vector<int> pids = get_pids();
    std::vector<ProcessInfo> processes;
    for (int pid : pids) {
        processes.push_back(get_process_info(pid));
    }

    // Sort by selected mode
    if (sort_mode == 'c') {
        std::sort(processes.begin(), processes.end(),
                  [](const ProcessInfo& a, const ProcessInfo& b) {
                      return a.cpu_usage > b.cpu_usage;
                  });
    } else { // default to memory sort
        std::sort(processes.begin(), processes.end(),
                  [](const ProcessInfo& a, const ProcessInfo& b) {
                      return a.mem_usage_kb > b.mem_usage_kb;
                  });
    }

    std::cout << "PID\tProcess Name\tMemory (KB)" << std::endl;
    std::cout << "-----------------------------------------" << std::endl;
    for (const auto& proc : processes) {
        std::cout << proc.pid << "\t" << proc.name << "\t\t" << proc.mem_usage_kb << std::endl;
    }
}

int main() {
    CpuTimes prev_cpu = read_cpu_times();
    char sort_mode = 'm'; // default sort by memory

    while (true) {
	if (kbhit()) {
            char ch = getchar();
            if (ch == 'c' || ch == 'm') {
                sort_mode = ch;
            } else if (ch == 'q') {
                break; // quit program
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
        CpuTimes curr_cpu = read_cpu_times();
        double cpu_usage = calculate_cpu_usage(prev_cpu, curr_cpu);
        prev_cpu = curr_cpu;

        auto [mem_total, mem_available] = read_memory();
        long long mem_used = mem_total - mem_available;

        // Clear screen
        std::cout << "\033[2J\033[1;1H";

        // System info summary
        std::cout << "System Monitor Tool\n\n";
        std::cout << "CPU Load: " << cpu_usage << " %\n";
        std::cout << "Memory Usage: " << mem_used / 1024 << " MB / " << mem_total / 1024 << " MB\n\n";
	std::cout << "Sort by: [c] CPU%  [m] Memory%  [q] Quit\n\n";

        display_process_list(sort_mode
        // Process listing
        display_process_list();

        std::cout.flush();
    }
    return 0;
}
